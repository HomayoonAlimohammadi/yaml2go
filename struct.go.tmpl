{{ $recipe := . }}
// Code generated by running "{{ $recipe.GenerateCmd }}". DO NOT EDIT.
//
// This file was autogenerated by the {{ $recipe.ToolName }} tool on {{ $recipe.GenerateDate }}.
// Any changes will be overwritten.
//
// These files are generated from the values.yaml files in the k8s/manifests/charts directory.
//
// Package {{ $recipe.PkgName }} contains the Go structs representing the values of the Helm chart.
package {{ $recipe.PkgName }}

{{ if $recipe.Imports }}
import (
    {{ range $import := $recipe.Imports -}}
        {{ if $import.Alias }} {{ $import.Alias }} {{ end }} "{{ $import.Path }}"
    {{ end }}
)
{{ end }}

{{ range $struct := $recipe.Structs }}
    {{- if $struct.DocString }}
        {{ $struct.DocString }}
    {{ end -}}

    type {{ $struct.Name }} struct {
        {{ range $field := $struct.Fields -}}
            {{- if $field.DocString -}}
                {{ $field.DocString }}
            {{ end -}}
            {{ $field.Name }} {{ $field.Type }} `json:"{{ $field.OriginalYamlName }},omitempty" yaml:"{{ $field.OriginalYamlName }},omitempty"`
        {{ end -}}

        {{- if $recipe.UnsafeFieldEnabled }}
            // UNSAFE. USE WITH CAUTION
			// 
			// {{ $recipe.UnsafeFieldName }} is a place for any additional fields that are not handled by the generator
			// The value of this field is going to be available as is in the output of `.ToMap()` method.
			// The fields in this map will overwrite other fields if their names match.
			// Field A has the same name as field B in the {{ $recipe.UnsafeFieldName }} map, if the json format
			// of field A is exactly equal to the actual string literal of field B.
			// Example:
			// 	type Values struct {
			// 		FieldA string `json:"myField"`
			//		{{ $recipe.UnsafeFieldName }} map[string]any
			// 	}
			// 	v := Values{
			//		FieldA:	"originalValue"
			// 		{{ $recipe.UnsafeFieldName }}: map[string]any{
			// 			"myField": "newValue", // same as FieldA json format
			//			"anotherField": "anotherValue", // new field that will be included in the map output
			// 		}
			// 	}
			//	v.ToMap() // returns map[string]any{"myField": "newValue", "anotherField": "anotherValue"}
            //
            // NOTE: Parent {{ $recipe.UnsafeFieldName }} fields will overwrite the child fields if they have the same name.
            {{ $recipe.UnsafeFieldName }} map[string]any `json:"-" yaml:"-"`
        {{ end }}
    }

    func (v *{{ $struct.Name }}) ToMap() (map[string]any, error) {
        if v == nil {
            return map[string]any{}, nil
        }
        b, err := json.Marshal(v)
        if err != nil {
            return nil, fmt.Errorf("failed to marshal struct to json: %w", err)
        }
        res := map[string]any{} 
        if err := json.Unmarshal(b, &res); err != nil {
            return nil, fmt.Errorf("failed to unmarshal json to map: %w", err)
        }
        {{ if $recipe.UnsafeFieldEnabled }}
            // Handle nested structs to take care of the nested {{ $recipe.UnsafeFieldName}}(s)
            val := reflect.ValueOf(v).Elem()
            typ := val.Type()
            for i := range val.NumField() {
                field := typ.Field(i)
                fieldValue := val.Field(i)

                fieldName := strings.Split(field.Tag.Get("json"), ",")[0]
                if fieldName == "-" || fieldName == "" {
                    fieldName = field.Name
                }

                var fValue reflect.Value
                if fieldValue.Kind() == reflect.Ptr && !fieldValue.IsNil() {
                    fValue = fieldValue.Elem()
                } else {
                    continue
                }

                if fValue.Kind() == reflect.Struct {
                    toMapMethod := fValue.Addr().MethodByName("ToMap")
                    if toMapMethod.IsValid() && toMapMethod.Type().NumOut() == 2 {
                        result := toMapMethod.Call(nil)
                        if len(result) != 2 {
                            return nil, fmt.Errorf("ToMap() method for fieldName %q should return 2 values", fieldName)
                        }
                        if !result[1].IsNil() {
                            err, ok := result[1].Interface().(error)
                            if !ok {
                                return nil, fmt.Errorf("second return value of ToMap() for fieldName %q should be an error", fieldName)
                            }
                            return nil, fmt.Errorf("failed to call ToMap() for fieldName %q: %w", fieldName, err)
                        }

                        toMapOutput := result[0].Interface()
                        if outputMap, ok := toMapOutput.(map[string]any); ok {
                            outerMap := map[string]any{fieldName: outputMap}
                            mergeMaps{{ $recipe.RootStructName }}(res, outerMap)
                        }
                    } else {
                        return nil, fmt.Errorf("ToMap() method for fieldName %q not found or does not have 2 return values", fieldName)
                    }
                }
            }

            if v.{{ $recipe.UnsafeFieldName }} != nil {
                mergeMaps{{ $recipe.RootStructName }}(res, v.{{ $recipe.UnsafeFieldName }})
            }
        {{ end -}}
        return res, nil
    }


{{ end }}

// mergeMaps recursively merges map B into map A. Inner maps will be recursively merged only if both are map[string]any.
// The name is unique to prevent conflicts with other autogenerated files in this package.
func mergeMaps{{ $recipe.RootStructName }}(a, b map[string]any) {
	for key, bValue := range b {
		if aValue, ok := a[key]; ok {
			aMap, aIsMap := aValue.(map[string]any)
			bMap, bIsMap := bValue.(map[string]any)
			if aIsMap && bIsMap {
				mergeMaps{{ $recipe.RootStructName }}(aMap, bMap)
				continue
			}
		}
		a[key] = bValue
	}
}

